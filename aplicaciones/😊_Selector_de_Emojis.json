{
  "id": "program-176653163608342",
  "type": "executable",
  "title": "ðŸ˜Š Selector de Emojis",
  "parentId": "folder-1766530794088863",
  "content": {
    "nodes": [
      {
        "id": "node-program-1766465470453144-0",
        "type": "start",
        "x": 50,
        "y": 50,
        "inputs": [],
        "outputs": [
          "out"
        ],
        "values": {},
        "uiFlags": {}
      },
      {
        "id": "node-program-1766465470453144-2",
        "type": "custom-emoji-picker",
        "x": 299.5,
        "y": 199.5,
        "inputs": [
          "open"
        ],
        "outputs": [
          "selected"
        ],
        "values": {},
        "uiFlags": {}
      }
    ],
    "connections": [
      {
        "fromNode": "node-program-1766465470453144-0",
        "fromPort": "out",
        "toNode": "node-program-1766465470453144-2",
        "toPort": "open"
      }
    ],
    "panX": 0,
    "panY": 0,
    "scale": 1,
    "embeddedModules": [
      {
        "id": "custom-emoji-picker",
        "title": "Selector Emojis",
        "color": "#eab308",
        "inputs": [
          "open"
        ],
        "outputs": [
          "selected"
        ],
        "fields": [],
        "code": "\n// ID Ãºnico para la ventana\nconst winId = 'custom-emoji-window';\nconst existing = document.getElementById(winId);\n\n// Si ya existe, la cerramos (Toggle)\nif (existing) {\n    existing.remove();\n    ctx.log(\"ðŸªŸ Ventana de emojis cerrada.\");\n    return;\n}\n\nctx.log(\"ðŸªŸ Abriendo selector de emojis...\");\n\n// 1. Rangos Unicode Principales (Emoticonos, SÃ­mbolos, Comida, Transporte, etc.)\nconst ranges = [\n    [0x1F600, 0x1F64F], // Smileys\n    [0x1F300, 0x1F5FF], // Misc Symbols\n    [0x1F680, 0x1F6FF], // Transport\n    [0x1F900, 0x1F9FF], // Supplemental\n    [0x1F1E6, 0x1F1FF], // Flags\n    [0x2600, 0x26FF],   // Misc\n    [0x2700, 0x27BF]    // Dingbats\n];\n\n// 2. Generar lista de emojis\nlet emojisHTML = '';\nfor (const range of ranges) {\n    for (let i = range[0]; i <= range[1]; i++) {\n        emojisHTML += `<button class=\"emoji-btn\" data-char=\"${String.fromCodePoint(i)}\">${String.fromCodePoint(i)}</button>`;\n    }\n}\n\n// 3. Crear Estructura DOM\nconst win = document.createElement('div');\nwin.id = winId;\nwin.className = 'window neumorph-out pop-in';\nwin.style.cssText = `\n    position: absolute;\n    top: 100px;\n    left: 100px;\n    width: 380px;\n    height: 500px;\n    z-index: 9999;\n    display: flex;\n    flex-direction: column;\n    background: #e0e5ec;\n    overflow: hidden;\n    resize: both;\n`;\n\n// Header con botÃ³n de cierre\nconst header = document.createElement('div');\nheader.className = 'window-header';\nheader.style.cssText = `\n    padding: 10px;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #e0e5ec;\n    cursor: grab;\n    border-bottom: 1px solid rgba(255,255,255,0.5);\n`;\nheader.innerHTML = `\n    <span style=\"font-weight:bold; color:#555; font-size:0.8rem;\">ðŸ˜€ Emojis</span>\n    <button id=\"close-${winId}\" style=\"border:none; background:transparent; cursor:pointer; font-size:1.2rem;\">Ã—</button>\n`;\n\n// Cuerpo (Grid de Emojis)\nconst body = document.createElement('div');\nbody.style.cssText = `\n    flex: 1;\n    padding: 10px;\n    overflow-y: auto;\n    display: flex;\n    flex-wrap: wrap;\n    gap: 5px;\n    justify-content: center;\n    align-content: flex-start;\n`;\n\n// Estilos CSS inyectados para los botones\nconst style = document.createElement('style');\nstyle.innerHTML = `\n    .emoji-btn {\n        width: 36px;\n        height: 36px;\n        font-size: 1.2rem;\n        border: none;\n        border-radius: 8px;\n        background: #e0e5ec;\n        box-shadow: 3px 3px 6px #b8b9be, -3px -3px 6px #ffffff;\n        cursor: pointer;\n        transition: transform 0.1s;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n    }\n    .emoji-btn:active {\n        box-shadow: inset 2px 2px 5px #b8b9be, inset -2px -2px 5px #ffffff;\n        transform: scale(0.95);\n    }\n    .emoji-btn:hover {\n        background: #f0f3f7;\n    }\n    /* Scrollbar */\n    #${winId} ::-webkit-scrollbar { width: 6px; }\n    #${winId} ::-webkit-scrollbar-thumb { background: #cbd5e0; border-radius: 3px; }\n`;\n\nbody.innerHTML = emojisHTML;\nwin.appendChild(style);\nwin.appendChild(header);\nwin.appendChild(body);\ndocument.body.appendChild(win);\n\n// 4. LÃ³gica de Eventos\n\n// Arrastrar ventana (Simple drag)\nlet isDragging = false;\nlet startX, startY, initLeft, initTop;\nheader.onmousedown = (e) => {\n    isDragging = true;\n    startX = e.clientX;\n    startY = e.clientY;\n    initLeft = win.offsetLeft;\n    initTop = win.offsetTop;\n    // Traer al frente\n    win.style.zIndex = parseInt(Date.now() / 10000);\n};\nwindow.addEventListener('mousemove', (e) => {\n    if (!isDragging) return;\n    win.style.left = (initLeft + (e.clientX - startX)) + 'px';\n    win.style.top = (initTop + (e.clientY - startY)) + 'px';\n});\nwindow.addEventListener('mouseup', () => isDragging = false);\n\n// Cerrar\ndocument.getElementById(`close-${winId}`).onclick = () => win.remove();\n\n// Clic en Emoji (DelegaciÃ³n de eventos)\nbody.onclick = (e) => {\n    const btn = e.target.closest('.emoji-btn');\n    if (btn) {\n        const char = btn.dataset.char;\n        \n        // Copiar al portapapeles\n        navigator.clipboard.writeText(char).then(() => {\n            ctx.log(`ðŸ“‹ Copiado: ${char}`);\n            \n            // Feedback visual\n            const original = btn.innerText;\n            btn.innerText = 'âœ…';\n            setTimeout(() => btn.innerText = original, 1000);\n        });\n\n        // Enviar al output del nodo por si se quiere usar en logica\n        // Nota: Esto solo funciona si el mÃ³dulo se ejecuta de nuevo, pero \n        // como es una ventana persistente, el return solo ocurre al crearla.\n        // Para enviar datos en tiempo real desde la ventana al flujo harÃ­a falta un callback complejo.\n        // Por ahora, solo copia.\n    }\n};\n\nreturn \"Ventana Abierta\";\n",
        "type": "custom-module",
        "_isExternal": true
      },
      {
        "id": "custom-self-exporter-exec-v22",
        "title": "Crear Ejecutable v2.2 (Autoportable)",
        "color": "#ef4444",
        "inputs": [
          "exec"
        ],
        "outputs": [],
        "fields": [
          {
            "name": "filename",
            "type": "text",
            "placeholder": "NombreApp"
          }
        ],
        "code": "\n// --- CREAR EJECUTABLE V2.2 (AUTOPORTABLE) ---\nconst name = ctx.fields.filename || \"App_\" + Date.now();\nctx.log(`âš¡ Procesando ejecutable autoportable: ${name}...`);\n\ntry {\n    // 1. Serializar el grafo actual\n    const fullData = ctx.graph.serialize();\n\n    // 2. EXTRAER DEFINICIONES DE MÃ“DULOS USADOS (La \"Portabilidad\")\n    // Identificamos quÃ© tipos de nodos hay en el grafo\n    const usedTypes = new Set(fullData.nodes.map(n => n.type));\n    \n    // Filtramos los mÃ³dulos personalizados que existen en el sistema y que estÃ¡n en el grafo\n    const embeddedModules = ProgrammerManager.customModules.filter(m => usedTypes.has(m.id));\n    \n    if (embeddedModules.length > 0) {\n        ctx.log(`ðŸ“¦ Embebiendo ${embeddedModules.length} mÃ³dulos personalizados...`);\n    }\n\n    // 3. CIRUGÃA: Extirpar este mismo nodo exportador para evitar bucles\n    const cleanNodes = fullData.nodes.filter(n => n.id !== ctx.nodeId);\n    const cleanConns = fullData.connections.filter(c => \n        c.fromNode !== ctx.nodeId && c.toNode !== ctx.nodeId\n    );\n\n    // 4. Reconstruir el objeto con las definiciones embebidas\n    const finalContent = {\n        ...fullData,\n        nodes: cleanNodes,\n        connections: cleanConns,\n        embeddedModules: embeddedModules, // <-- AQUÃ VA LA MAGIA\n        panX: 0, panY: 0, scale: 1\n    };\n\n    // 5. Crear el archivo en el Sistema\n    if (typeof FileSystem !== 'undefined') {\n        const newProg = FileSystem.createProgram(name, 'desktop');\n        \n        newProg.type = 'executable'; \n        newProg.icon = 'zap'; \n        newProg.color = 'text-yellow-500';\n        newProg.content = finalContent;\n        \n        FileSystem.save();\n        if (typeof refreshSystemViews === 'function') refreshSystemViews();\n        \n        ctx.log(`âœ… Â¡Ã‰xito! \"${name}\" es ahora autoportable.`);\n    } else {\n        ctx.log(\"âŒ Error: No se encuentra el Sistema de Archivos.\");\n    }\n} catch (e) {\n    ctx.log(\"âŒ Error: \" + e.message);\n}\n",
        "_isExternal": false
      }
    ]
  },
  "x": 0,
  "y": 0,
  "icon": "zap",
  "color": "text-yellow-500"
}