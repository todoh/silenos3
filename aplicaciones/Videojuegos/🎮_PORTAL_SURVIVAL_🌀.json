{
  "id": "program-portal-survival-v1",
  "type": "executable",
  "title": "üéÆ PORTAL SURVIVAL üåÄ",
  "parentId": "folder-1766546174407462",
  "content": {
    "nodes": [
      {
        "id": "node-start",
        "type": "start",
        "x": 50,
        "y": 50,
        "inputs": [],
        "outputs": [
          "out"
        ],
        "values": {},
        "uiFlags": {}
      },
      {
        "id": "node-engine",
        "type": "portal-survival-core",
        "x": 300,
        "y": 50,
        "inputs": [
          "open"
        ],
        "outputs": [
          "exit"
        ],
        "values": {}
      }
    ],
    "connections": [
      {
        "fromNode": "node-start",
        "fromPort": "out",
        "toNode": "node-engine",
        "toPort": "open"
      }
    ],
    "embeddedModules": [
      {
        "id": "portal-survival-core",
        "title": "üåÄ PORTAL SURVIVAL: CONTINUUM üåÄ",
        "color": "#8b5cf6",
        "inputs": [
          "open"
        ],
        "outputs": [
          "exit"
        ],
        "code": "const winId = 'portal-survival-window';\nconst existing = document.getElementById(winId);\nif (existing) { existing.remove(); return; }\n\n// ==========================================\n// [F] FORMA & [M] MATERIA: CONFIGURACI√ìN\n// ==========================================\nconst WIDTH = 800;\nconst HEIGHT = 600;\nconst WORLD_SIZE = 5000; \n\nconst ENTITY_TYPES = {\n    PORTAL: { colors: ['#ff4ef0', '#4efff0', '#f0ff4e', '#4eff52', '#ff4e4e'] },\n    ENEMY: [\n        { type: 'Sombra', speed: 1.5, hp: 2, pts: 10, color: '#ff4ef0' },\n        { type: 'Espectro', speed: 2.5, hp: 1, pts: 15, color: '#4efff0' },\n        { type: 'Tanque', speed: 0.8, hp: 5, pts: 30, color: '#f0ff4e' },\n        { type: 'Veloz', speed: 3.5, hp: 1, pts: 20, color: '#4eff52' },\n        { type: 'Berserker', speed: 1.2, hp: 8, pts: 50, color: '#ff4e4e' }\n    ],\n    NPC: [\n        { type: 'Protector', color: '#34eb74', range: 300, fireRate: 1000 },\n        { type: 'Vitalista', color: '#eb3434', range: 150, healRate: 3000 }\n    ]\n};\n\nlet state = {\n    level: 1,\n    score: 0,\n    gameActive: true,\n    victory: false,\n    levelThresholds: [0, 500, 1500, 3000, 5000, 8000]\n};\n\nlet player = {\n    x: WORLD_SIZE / 2,\n    y: WORLD_SIZE / 2,\n    w: 25, h: 25,\n    hp: 10, maxHp: 10,\n    speed: 5,\n    bullets: [],\n    lastShot: 0\n};\n\nlet enemies = [];\nlet portals = [];\nlet items = [];\nlet npcs = [];\nconst keys = {};\n\n// ==========================================\n// [L] L√çMITE Y [D] CONTENEDOR: INTERFAZ\n// ==========================================\nconst win = document.createElement('div');\nwin.id = winId;\nwin.style.cssText = `\n    position: absolute; \n    top: 50px; \n    left: 50px; \n    width: ${WIDTH}px; \n    height: ${HEIGHT + 30}px; \n    z-index: 10000; \n    background: #050505; \n    border: 2px solid #444; \n    border-radius: 8px; \n    overflow: hidden; \n    font-family: 'Courier New', monospace; \n    color: white;\n    box-shadow: 0 10px 30px rgba(0,0,0,0.5);\n    user-select: none;\n`;\n\n// Barra de t√≠tulo (Arrastrable)\nconst titleBar = document.createElement('div');\ntitleBar.style.cssText = `\n    background: #1a1a1a;\n    height: 30px;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 0 10px;\n    cursor: move;\n    border-bottom: 1px solid #333;\n`;\ntitleBar.innerHTML = `<span style=\"font-size: 12px; color: #8b5cf6; font-weight: bold;\">üåÄ PORTAL SURVIVAL: CONTINUUM</span>`;\n\nconst closeBtn = document.createElement('div');\ncloseBtn.innerHTML = '‚úï';\ncloseBtn.style.cssText = `\n    cursor: pointer;\n    color: #666;\n    font-weight: bold;\n    padding: 2px 8px;\n    transition: 0.2s;\n`;\ncloseBtn.onmouseover = () => closeBtn.style.color = '#ff4e4e';\ncloseBtn.onmouseout = () => closeBtn.style.color = '#666';\ncloseBtn.onclick = () => win.remove();\n\ntitleBar.appendChild(closeBtn);\nwin.appendChild(titleBar);\n\nconst canvas = document.createElement('canvas');\ncanvas.width = WIDTH; \ncanvas.height = HEIGHT;\nconst ctx = canvas.getContext('2d');\n\nconst ui = document.createElement('div');\nui.style.cssText = `position: absolute; top: 40px; left: 10px; pointer-events: none; text-shadow: 2px 2px black; font-size: 16px;`;\n\nwin.append(canvas, ui);\ndocument.body.appendChild(win);\n\n// L√≥gica de Arrastre [K]\nlet isDragging = false;\nlet startX, startY;\n\ntitleBar.onmousedown = (e) => {\n    isDragging = true;\n    startX = e.clientX - win.offsetLeft;\n    startY = e.clientY - win.offsetTop;\n};\n\nwindow.addEventListener('mousemove', (e) => {\n    if (isDragging) {\n        win.style.left = (e.clientX - startX) + 'px';\n        win.style.top = (e.clientY - startY) + 'px';\n    }\n});\n\nwindow.addEventListener('mouseup', () => {\n    isDragging = false;\n});\n\n// ==========================================\n// [K] KI: L√ìGICA DE JUEGO\n// ==========================================\nconst wrap = (val, max) => (val % max + max) % max;\n\nconst getWrappedDist = (a, b) => {\n    let dx = a.x - b.x;\n    let dy = a.y - b.y;\n    if (Math.abs(dx) > WORLD_SIZE / 2) dx = -Math.sign(dx) * (WORLD_SIZE - Math.abs(dx));\n    if (Math.abs(dy) > WORLD_SIZE / 2) dy = -Math.sign(dy) * (WORLD_SIZE - Math.abs(dy));\n    return { dx, dy, dist: Math.sqrt(dx*dx + dy*dy) };\n};\n\nconst spawnPortal = (index) => {\n    portals.push({\n        x: Math.random() * WORLD_SIZE,\n        y: Math.random() * WORLD_SIZE,\n        type: index,\n        lastSpawn: 0,\n        hp: 10 + (state.level * 5)\n    });\n};\n\nconst spawnNPC = () => {\n    const typeData = ENTITY_TYPES.NPC[Math.floor(Math.random() * ENTITY_TYPES.NPC.length)];\n    npcs.push({\n        ...typeData,\n        x: Math.random() * WORLD_SIZE,\n        y: Math.random() * WORLD_SIZE,\n        lastAction: 0\n    });\n};\n\nconst initLevel = () => {\n    portals = []; enemies = []; items = []; npcs = [];\n    for (let i = 0; i < state.level + 2; i++) spawnPortal(i % 5);\n    for (let i = 0; i < 8; i++) spawnNPC();\n};\n\nconst spawnItem = (x, y) => {\n    items.push({\n        x, y, \n        type: Math.random() > 0.8 ? 'potion' : 'coin',\n        color: Math.random() > 0.8 ? '#ff0000' : '#ffd700'\n    });\n};\n\nconst update = () => {\n    if (!state.gameActive) return;\n\n    if (keys['w']) player.y -= player.speed;\n    if (keys['s']) player.y += player.speed;\n    if (keys['a']) player.x -= player.speed;\n    if (keys['d']) player.x += player.speed;\n\n    player.x = wrap(player.x, WORLD_SIZE);\n    player.y = wrap(player.y, WORLD_SIZE);\n\n    portals.forEach(p => {\n        if (Date.now() - p.lastSpawn > 4000 / state.level) {\n            const data = ENTITY_TYPES.ENEMY[p.type];\n            enemies.push({ ...data, x: p.x, y: p.y, w: 20, h: 20 });\n            p.lastSpawn = Date.now();\n        }\n    });\n\n    npcs.forEach(npc => {\n        const toPlayer = getWrappedDist(player, npc);\n        if (npc.type === 'Protector') {\n            if (Date.now() - npc.lastAction > npc.fireRate) {\n                const target = enemies.find(en => getWrappedDist(en, npc).dist < npc.range);\n                if (target) {\n                    const info = getWrappedDist(target, npc);\n                    const angle = Math.atan2(info.dy, info.dx);\n                    player.bullets.push({\n                        x: npc.x, y: npc.y,\n                        vx: Math.cos(angle) * 7, vy: Math.sin(angle) * 7,\n                        life: 80, fromNPC: true\n                    });\n                    npc.lastAction = Date.now();\n                }\n            }\n        } else if (npc.type === 'Vitalista') {\n            if (toPlayer.dist < npc.range && Date.now() - npc.lastAction > npc.healRate) {\n                player.hp = Math.min(player.maxHp, player.hp + 1);\n                npc.lastAction = Date.now();\n            }\n        }\n        if (toPlayer.dist > 1000) {\n            npc.x += (toPlayer.dx / toPlayer.dist) * 1;\n            npc.y += (toPlayer.dy / toPlayer.dist) * 1;\n            npc.x = wrap(npc.x, WORLD_SIZE);\n            npc.y = wrap(npc.y, WORLD_SIZE);\n        }\n    });\n\n    enemies.forEach((en, index) => {\n        const info = getWrappedDist(player, en);\n        en.x += (info.dx / info.dist) * en.speed;\n        en.y += (info.dy / info.dist) * en.speed;\n        en.x = wrap(en.x, WORLD_SIZE);\n        en.y = wrap(en.y, WORLD_SIZE);\n        if (info.dist < 20) {\n            player.hp -= 0.05;\n            if (player.hp <= 0) state.gameActive = false;\n        }\n    });\n\n    player.bullets.forEach((b, bi) => {\n        b.x += b.vx; b.y += b.vy;\n        b.x = wrap(b.x, WORLD_SIZE);\n        b.y = wrap(b.y, WORLD_SIZE);\n        b.life--;\n        enemies.forEach((en, ei) => {\n            const d = getWrappedDist(b, en).dist;\n            if (d < 20) {\n                en.hp--; b.life = 0;\n                if (en.hp <= 0) {\n                    state.score += en.pts;\n                    if (Math.random() < 0.2) spawnItem(en.x, en.y);\n                    enemies.splice(ei, 1);\n                }\n            }\n        });\n    });\n    player.bullets = player.bullets.filter(b => b.life > 0);\n\n    items.forEach((it, i) => {\n        const d = getWrappedDist(player, it).dist;\n        if (d < 25) {\n            if (it.type === 'coin') state.score += 50;\n            if (it.type === 'potion') player.hp = Math.min(player.maxHp, player.hp + 2);\n            items.splice(i, 1);\n        }\n    });\n\n    if (state.score >= state.levelThresholds[state.level]) {\n        if (state.level < 5) {\n            state.level++;\n            initLevel();\n        } else {\n            state.victory = true;\n            state.gameActive = false;\n        }\n    }\n};\n\n// ==========================================\n// [B] VISI√ìN: RENDERIZADO\n// ==========================================\nconst drawEntity = (e, color, size = 20, isSquare = true) => {\n    const camX = player.x - WIDTH / 2;\n    const camY = player.y - HEIGHT / 2;\n    for (let ox = -1; ox <= 1; ox++) {\n        for (let oy = -1; oy <= 1; oy++) {\n            const dx = (e.x + ox * WORLD_SIZE) - camX;\n            const dy = (e.y + oy * WORLD_SIZE) - camY;\n            if (dx > -100 && dx < WIDTH + 100 && dy > -100 && dy < HEIGHT + 100) {\n                ctx.fillStyle = color;\n                if (isSquare) ctx.fillRect(dx - size/2, dy - size/2, size, size);\n                else {\n                    ctx.beginPath();\n                    ctx.arc(dx, dy, size/2, 0, Math.PI * 2);\n                    ctx.fill();\n                }\n                if(e.type === 'Protector' || e.type === 'Vitalista') {\n                    ctx.strokeStyle = color;\n                    ctx.lineWidth = 2;\n                    ctx.beginPath();\n                    ctx.arc(dx, dy, size * 0.8, 0, Math.PI * 2);\n                    ctx.stroke();\n                }\n            }\n        }\n    }\n};\n\nconst render = () => {\n    if (!document.getElementById(winId)) return; // Detener si se cierra\n\n    ctx.fillStyle = '#050505';\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    ctx.strokeStyle = '#111';\n    ctx.lineWidth = 1;\n    const gap = 200;\n    const offsetX = -(player.x % gap);\n    const offsetY = -(player.y % gap);\n    for(let x = offsetX; x < WIDTH; x += gap) {\n        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, HEIGHT); ctx.stroke();\n    }\n    for(let y = offsetY; y < HEIGHT; y += gap) {\n        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(WIDTH, y); ctx.stroke();\n    }\n\n    portals.forEach(p => drawEntity(p, ENTITY_TYPES.PORTAL.colors[p.type], 50));\n    items.forEach(it => drawEntity(it, it.color, 15, false));\n    npcs.forEach(n => drawEntity(n, n.color, 25));\n    enemies.forEach(en => drawEntity(en, en.color, 22));\n    player.bullets.forEach(b => drawEntity(b, b.fromNPC ? '#34eb74' : '#fff', 8, false));\n    drawEntity(player, '#3498db', 30);\n\n    ui.innerHTML = `\n        <span style=\"color:#8b5cf6\">AREA: ${WORLD_SIZE}x${WORLD_SIZE}</span> | \n        LEVEL: ${state.level}/5 | SCORE: ${state.score}<br>\n        HP: ${'‚ù§Ô∏è'.repeat(Math.max(0, Math.ceil(player.hp/2)))} (${Math.ceil(player.hp)})<br>\n        <span style=\"font-size:12px; color:#aaa\">Usa la barra superior para mover la ventana.</span>\n    `;\n\n    if (!state.gameActive) {\n        ctx.fillStyle = 'rgba(0,0,0,0.85)';\n        ctx.fillRect(0,0,WIDTH,HEIGHT);\n        ctx.fillStyle = 'white';\n        ctx.textAlign = 'center';\n        ctx.font = 'bold 40px monospace';\n        ctx.fillText(state.victory ? 'DOMINIO ALCANZADO' : 'SISTEMA COLAPSADO', WIDTH/2, HEIGHT/2);\n        ctx.font = '20px monospace';\n        ctx.fillText('Pulsa R para reiniciar el ciclo', WIDTH/2, HEIGHT/2 + 60);\n    }\n\n    update();\n    requestAnimationFrame(render);\n};\n\n// ==========================================\n// [J] JUEGOS: INTERACCI√ìN\n// ==========================================\nwindow.onkeydown = (e) => {\n    keys[e.key.toLowerCase()] = true;\n    if (e.key.toLowerCase() === 'r' && !state.gameActive) {\n        state = { level: 1, score: 0, gameActive: true, victory: false, levelThresholds: [0, 500, 1500, 3000, 5000, 8000] };\n        player.hp = 10; player.bullets = [];\n        initLevel();\n    }\n};\nwindow.onkeyup = (e) => keys[e.key.toLowerCase()] = false;\n\ncanvas.onmousedown = (e) => {\n    if (!state.gameActive) return;\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n    const angle = Math.atan2(my - HEIGHT/2, mx - WIDTH/2);\n    player.bullets.push({\n        x: player.x, y: player.y,\n        vx: Math.cos(angle) * 10, vy: Math.sin(angle) * 10,\n        life: 120\n    });\n};\n\ninitLevel();\nrender();\n\nreturn \"H (Coherencia) aplicada: Ventana m√≥vil y cierre de sistema habilitado.\";"
      }
    ]
  },
  "icon": "zap",
  "color": "text-purple-500",
  "x": 0,
  "y": 0
}