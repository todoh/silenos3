{
  "id": "program-minecraft-2d-v3-modular",
  "type": "executable",
  "title": "üéÆ TERRARIO 2D ‚õèÔ∏è",
  "parentId": "folder-1766546174407462",
  "content": {
    "nodes": [
      {
        "id": "node-start",
        "type": "start",
        "x": 50,
        "y": 50,
        "inputs": [],
        "outputs": [
          "out"
        ],
        "values": {},
        "uiFlags": {}
      },
      {
        "id": "node-engine",
        "type": "mc-modular-v3",
        "x": 300,
        "y": 50,
        "inputs": [
          "open"
        ],
        "outputs": [
          "exit"
        ],
        "values": {
          "seed": "MODULAR-2025"
        }
      }
    ],
    "connections": [
      {
        "fromNode": "node-start",
        "fromPort": "out",
        "toNode": "node-engine",
        "toPort": "open"
      }
    ],
    "panX": 0,
    "panY": 0,
    "scale": 1,
    "embeddedModules": [
      {
        "id": "mc-modular-v3",
        "title": "‚õèÔ∏è MC 2D V3: MODULAR H ‚õèÔ∏è",
        "color": "#059669",
        "inputs": [
          "open"
        ],
        "outputs": [
          "exit"
        ],
        "fields": [],
        "code": "const winId = 'mc-v3-modular-window';\nconst existing = document.getElementById(winId);\nif (existing) { existing.remove(); return; }\n\n// ==========================================\n// [T1] CONFIGURACI√ìN & MATERIA (M)\n// ==========================================\nconst TILE_SIZE = 32;\nconst COLS = 100;\nconst ROWS = 120;\nconst WORLD_WIDTH = COLS * TILE_SIZE;\n\nconst BLOCKS = {\n    0: { name: 'AIRE', color: '#87CEEB', emoji: '‚òÅÔ∏è', solid: false },\n    1: { name: 'TIERRA', color: '#795548', emoji: 'üü´', solid: true },\n    2: { name: 'CESPED', color: '#4CAF50', emoji: 'üü©', solid: true },\n    3: { name: 'PIEDRA', color: '#607d8b', emoji: 'üî≤', solid: true },\n    4: { name: 'MADERA', color: '#5d4037', emoji: 'üüß', solid: true },\n    5: { name: 'HOJAS', color: '#2e7d32', emoji: 'üçÉ', solid: true },\n    6: { name: 'LAVA', color: '#ff4500', emoji: 'üî•', solid: false }\n};\n\nlet inventory = { 1: 10, 2: 10, 3: 5, 4: 5, 5: 5, 6: 0 };\nlet world = [];\nlet mobs = [];\nlet selectedBlock = 1;\nlet isDraggingWindow = false;\nlet offset = { x: 0, y: 0 };\nconst keys = {};\n\nconst player = {\n    x: 150, y: 100,\n    vx: 0, vy: 0,\n    w: 24, h: 36,\n    hp: 10, \n    maxHp: 10,\n    invulnerable: 0,\n    grounded: false,\n    facing: 1\n};\n\n// ==========================================\n// [T2] GENERACI√ìN & F√çSICAS (K - Ki)\n// ==========================================\nconst resetPlayer = () => {\n    player.x = 150;\n    player.y = 100;\n    player.vx = 0;\n    player.vy = 0;\n    player.hp = player.maxHp;\n};\n\nconst takeDamage = (amount) => {\n    if (player.invulnerable > 0) return;\n    player.hp -= amount;\n    player.invulnerable = 60; \n    if (player.hp <= 0) resetPlayer();\n};\n\nconst spawnMobs = () => {\n    mobs = [];\n    for (let i = 0; i < 8; i++) {\n        const rx = Math.floor(Math.random() * COLS);\n        mobs.push({\n            x: rx * TILE_SIZE,\n            y: 0,\n            vx: Math.random() > 0.5 ? 1.2 : -1.2,\n            vy: 0,\n            w: 24, h: 32,\n            type: 'ZOMBIE',\n            hp: 3\n        });\n    }\n};\n\nconst generateWorld = () => {\n    world = Array.from({ length: ROWS }, () => Array(COLS).fill(0));\n    for (let x = 0; x < COLS; x++) {\n        const surface = Math.floor(Math.sin(x * 0.1) * 3 + Math.cos(x * 0.05) * 2) + 20;\n        for (let y = 0; y < ROWS; y++) {\n            if (y >= ROWS - 4) world[y][x] = 6;\n            else if (y > surface + 8) world[y][x] = 3;\n            else if (y > surface) world[y][x] = 1;\n            else if (y === surface) world[y][x] = 2;\n        }\n        if (x > 5 && x < COLS - 5 && Math.random() < 0.12) {\n            const groundY = surface;\n            if (world[groundY][x] === 2) {\n                const trunkHeight = 3 + Math.floor(Math.random() * 3);\n                for (let h = 1; h <= trunkHeight; h++) if (groundY - h > 0) world[groundY - h][x] = 4;\n                for (let ly = -2; ly <= 0; ly++) {\n                    for (let lx = -2; lx <= 2; lx++) {\n                        const leafY = groundY - trunkHeight + ly;\n                        const leafX = (x + lx + COLS) % COLS;\n                        if (leafY > 0 && Math.abs(lx) + Math.abs(ly) < 4) world[leafY][leafX] = 5;\n                    }\n                }\n            }\n        }\n    }\n    spawnMobs();\n};\n\nconst checkBlockCollision = (nx, ny, objW, objH) => {\n    const top = Math.floor(ny / TILE_SIZE);\n    const bottom = Math.floor((ny + objH) / TILE_SIZE);\n    if (top < 0 || bottom >= ROWS) return true;\n    for (let j = top; j <= bottom; j++) {\n        for (let i = nx; i <= nx + objW; i += objW) {\n            const gx = Math.floor(i / TILE_SIZE);\n            const wrappedX = (gx % COLS + COLS) % COLS;\n            const blockId = world[j][wrappedX];\n            if (BLOCKS[blockId].solid) return true;\n            if (objW === player.w && blockId === 6) { takeDamage(1); return false; }\n        }\n    }\n    return false;\n};\n\nconst updateEntities = () => {\n    if (keys['a']) { player.vx = -5; player.facing = -1; }\n    else if (keys['d']) { player.vx = 5; player.facing = 1; }\n    else player.vx *= 0.8;\n    \n    if ((keys['w'] || keys[' ']) && player.grounded) { player.vy = -9; player.grounded = false; }\n    player.vy += 0.45;\n    \n    if (!checkBlockCollision(player.x + player.vx, player.y, player.w, player.h)) player.x += player.vx;\n    player.x = (player.x % WORLD_WIDTH + WORLD_WIDTH) % WORLD_WIDTH;\n    \n    if (!checkBlockCollision(player.x, player.y + player.vy, player.w, player.h)) {\n        player.y += player.vy;\n        player.grounded = false;\n    } else {\n        if (player.vy > 0) player.grounded = true;\n        player.vy = 0;\n    }\n    \n    if (player.invulnerable > 0) player.invulnerable--;\n\n    mobs.forEach(mob => {\n        mob.vy += 0.45;\n        if (!checkBlockCollision(mob.x + mob.vx, mob.y, mob.w, mob.h)) {\n            mob.x += mob.vx;\n        } else {\n            mob.vx *= -1; \n        }\n        mob.x = (mob.x % WORLD_WIDTH + WORLD_WIDTH) % WORLD_WIDTH;\n\n        if (!checkBlockCollision(mob.x, mob.y + mob.vy, mob.w, mob.h)) {\n            mob.y += mob.vy;\n        } else {\n            mob.vy = 0;\n        }\n\n        const dx = Math.abs((player.x + player.w/2) - (mob.x + mob.w/2));\n        const dy = Math.abs((player.y + player.h/2) - (mob.y + mob.h/2));\n        if (dx < 20 && dy < 30) takeDamage(2);\n    });\n};\n\n// ==========================================\n// [T3] INTERFAZ & VISUALIZACI√ìN\n// ==========================================\nconst win = document.createElement('div');\nwin.id = winId;\nwin.style.cssText = `position: absolute; top: 50px; left: 50px; width: 800px; z-index: 10000; background: #1a1a1a; border: 2px solid #333; border-radius: 12px; overflow: hidden; font-family: 'Segoe UI', sans-serif; box-shadow: 0 10px 40px rgba(0,0,0,0.6);`;\n\nconst header = document.createElement('div');\nheader.style.cssText = `background: #333; padding: 12px; color: #eee; cursor: grab; display: flex; justify-content: space-between; align-items: center;`;\nheader.innerHTML = `<span><b>‚õèÔ∏è MC 2D: SURVIVAL H-V3</b></span><span id=\"close-mc\" style=\"cursor:pointer; background:#ff5252; padding:2px 8px; border-radius:4px;\">‚úñ</span>`;\n\nconst inventoryBar = document.createElement('div');\ninventoryBar.style.cssText = `position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 8px; background: rgba(0,0,0,0.85); padding: 10px; border-radius: 12px; border: 2px solid #444; backdrop-filter: blur(5px);`;\n\nconst healthBar = document.createElement('div');\nhealthBar.style.cssText = `position: absolute; top: 60px; left: 20px; display: flex; gap: 4px;`;\n\nconst updateUI = () => {\n    inventoryBar.innerHTML = '';\n    Object.keys(BLOCKS).forEach(id => {\n        if (id == 0) return;\n        const count = inventory[id];\n        const slot = document.createElement('div');\n        slot.style.cssText = `position: relative; width: 45px; height: 45px; display: flex; align-items: center; justify-content: center; font-size: 20px; background: ${selectedBlock == id ? '#4CAF5033' : '#222'}; border: 2px solid ${selectedBlock == id ? '#4CAF50' : '#333'}; border-radius: 8px; cursor: pointer; transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1); opacity: ${count > 0 ? '1' : '0.4'}; transform: ${selectedBlock == id ? 'scale(1.1)' : 'scale(1)'};`;\n        slot.innerHTML = BLOCKS[id].emoji;\n        const label = document.createElement('span');\n        label.style.cssText = `position: absolute; bottom: -2px; right: 2px; font-size: 10px; color: white; background: rgba(0,0,0,0.7); padding: 1px 4px; border-radius: 4px; font-weight: bold;`;\n        label.innerText = count;\n        slot.appendChild(label);\n        slot.onclick = () => { selectedBlock = parseInt(id); updateUI(); };\n        inventoryBar.appendChild(slot);\n    });\n\n    healthBar.innerHTML = '';\n    for (let i = 0; i < 5; i++) {\n        const heart = document.createElement('span');\n        const hpVal = player.hp - (i * 2);\n        heart.innerText = hpVal >= 2 ? '‚ù§Ô∏è' : (hpVal === 1 ? 'üíî' : 'üñ§');\n        heart.style.fontSize = '20px';\n        healthBar.appendChild(heart);\n    }\n};\n\nconst canvas = document.createElement('canvas');\ncanvas.width = 800; canvas.height = 500;\nconst ctx = canvas.getContext('2d');\n\nwin.append(header, canvas, inventoryBar, healthBar);\ndocument.body.appendChild(win);\n\n// ==========================================\n// [T4] MOTOR DE VISI√ìN (B)\n// ==========================================\nconst render = () => {\n    ctx.fillStyle = BLOCKS[0].color;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const camX = player.x - canvas.width / 2;\n    const camY = Math.max(0, Math.min(player.y - canvas.height / 2, (ROWS * TILE_SIZE) - canvas.height));\n\n    ctx.save();\n    ctx.translate(-camX, -camY);\n\n    const draws = [-WORLD_WIDTH, 0, WORLD_WIDTH];\n    draws.forEach(off => {\n        const startX = Math.max(0, Math.floor((camX - off) / TILE_SIZE));\n        const endX = Math.min(COLS, Math.ceil((camX - off + canvas.width) / TILE_SIZE));\n        const startY = Math.max(0, Math.floor(camY / TILE_SIZE));\n        const endY = Math.min(ROWS, Math.ceil((camY + canvas.height) / TILE_SIZE));\n\n        for (let y = startY; y < endY; y++) {\n            for (let x = startX; x < endX; x++) {\n                const bid = world[y][x];\n                if (bid !== 0) {\n                    ctx.fillStyle = BLOCKS[bid].color;\n                    ctx.fillRect(x * TILE_SIZE + off, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);\n                    ctx.strokeStyle = 'rgba(0,0,0,0.05)';\n                    ctx.strokeRect(x * TILE_SIZE + off, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);\n                }\n            }\n        }\n        \n        mobs.forEach(mob => {\n            ctx.fillStyle = mob.hp < 3 ? '#e74c3c' : '#4a7c59'; \n            ctx.fillRect(mob.x + off, mob.y, mob.w, mob.h);\n            ctx.fillStyle = 'black';\n            ctx.fillRect(mob.x + off + (mob.vx > 0 ? 16 : 4), mob.y + 6, 4, 4);\n        });\n    });\n\n    if (!(player.invulnerable > 0 && Math.floor(Date.now() / 100) % 2 === 0)) {\n        const px = player.x; const py = player.y;\n        ctx.fillStyle = '#3498db'; ctx.fillRect(px, py + 12, player.w, 18);\n        ctx.fillStyle = '#2c3e50'; ctx.fillRect(px, py + 30, player.w, 6);\n        ctx.fillStyle = '#ffdbac'; ctx.fillRect(px + 2, py, player.w - 4, 12);\n        ctx.fillStyle = 'white';\n        const eyeX = player.facing === 1 ? px + 14 : px + 4;\n        ctx.fillRect(eyeX, py + 3, 6, 4);\n        ctx.fillStyle = 'black';\n        ctx.fillRect(eyeX + (player.facing === 1 ? 3 : 1), py + 4, 2, 2);\n    }\n\n    ctx.restore();\n    updateEntities();\n    updateUI(); \n    requestAnimationFrame(render);\n};\n\n// ==========================================\n// [T5] EVENTOS & INTERACCI√ìN (J - Juegos)\n// ==========================================\nheader.onmousedown = (e) => { isDraggingWindow = true; offset.x = e.clientX - win.offsetLeft; offset.y = e.clientY - win.offsetTop; };\nwindow.addEventListener('mousemove', (e) => { if (isDraggingWindow) { win.style.left = (e.clientX - offset.x) + 'px'; win.style.top = (e.clientY - offset.y) + 'px'; } });\nwindow.addEventListener('mouseup', () => isDraggingWindow = false);\n\n// Cambio de objeto con RUEDA DEL RAT√ìN [J]\nwin.addEventListener('wheel', (e) => {\n    const blockIds = Object.keys(BLOCKS).filter(id => id != 0);\n    let currentIndex = blockIds.indexOf(selectedBlock.toString());\n    if (e.deltaY > 0) currentIndex++;\n    else currentIndex--;\n    \n    if (currentIndex >= blockIds.length) currentIndex = 0;\n    if (currentIndex < 0) currentIndex = blockIds.length - 1;\n    \n    selectedBlock = parseInt(blockIds[currentIndex]);\n    updateUI();\n}, { passive: true });\n\ncanvas.onmousedown = (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const camX = player.x - canvas.width / 2;\n    const camY = Math.max(0, Math.min(player.y - canvas.height / 2, (ROWS * TILE_SIZE) - canvas.height));\n    const mx = e.clientX - rect.left + camX;\n    const my = e.clientY - rect.top + camY;\n\n    if (e.button === 0) {\n        let hitMob = false;\n        for (let i = mobs.length - 1; i >= 0; i--) {\n            const m = mobs[i];\n            if (mx >= m.x && mx <= m.x + m.w && my >= m.y && my <= m.y + m.h) {\n                m.hp--;\n                hitMob = true;\n                if (m.hp <= 0) mobs.splice(i, 1);\n                break;\n            }\n        }\n        if (hitMob) return;\n    }\n\n    const gx = (Math.floor(mx / TILE_SIZE) % COLS + COLS) % COLS;\n    const gy = Math.floor(my / TILE_SIZE);\n    \n    if (gy >= 0 && gy < ROWS) {\n        if (e.button === 0) {\n            const blockToBreak = world[gy][gx];\n            if (blockToBreak !== 0 && blockToBreak !== 6) {\n                inventory[blockToBreak] = (inventory[blockToBreak] || 0) + 1;\n                world[gy][gx] = 0;\n            }\n        }\n        if (e.button === 2) {\n            if (world[gy][gx] === 0 && inventory[selectedBlock] > 0) {\n                world[gy][gx] = selectedBlock;\n                inventory[selectedBlock]--;\n            }\n        }\n    }\n};\n\ncanvas.oncontextmenu = (e) => e.preventDefault();\nwindow.onkeydown = (e) => {\n    keys[e.key.toLowerCase()] = true;\n    // Cambio r√°pido con n√∫meros 1-6 [N]\n    if (e.key >= '1' && e.key <= '6') {\n        const blockIds = Object.keys(BLOCKS).filter(id => id != 0);\n        const idx = parseInt(e.key) - 1;\n        if (idx < blockIds.length) {\n            selectedBlock = parseInt(blockIds[idx]);\n            updateUI();\n        }\n    }\n};\nwindow.onkeyup = (e) => keys[e.key.toLowerCase()] = false;\ndocument.getElementById('close-mc').onclick = () => win.remove();\n\ngenerateWorld();\nrender();\n\nreturn \"H (Coherencia) establecida: Sistema de navegaci√≥n de inventario activo.\";"
      }
    ]
  },
  "x": 0,
  "y": 0,
  "icon": "box",
  "color": "text-emerald-500"
}